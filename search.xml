<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D(es6%2Bes5)%2F</url>
    <content type="text"><![CDATA[1. 利用一个json对象原理: 循环数组里面的每一项设置为json的key, value为 1.1234567891011121314Array.prototype.removal_one = function () &#123; let jsn = &#123;&#125;, arr1 = [], len = this.length; for (let i = 0; i &lt; len; i++) &#123; const item = this[i] if (!jsn[item]) &#123; jsn[item] = 1; arr1.push(item); &#125; &#125; return arr1; &#125; 2. 利用 indexOf()原理: 在新数组里查找旧数组的每一项,没有就添加进来.12345678910Array.prototype.removal_two = function () &#123; let arr1 = []; let len = this.length; for (let i = 0; i &lt; len; i++) &#123; if (arr1.indexOf(this[i]) == -1) &#123; arr1.push(this[i]); &#125; &#125; return arr1;&#125; 3. 利用 indexOf()原理: 同 2.123456789Array.prototype.removal_three = function () &#123; let arr1 = []; this.map((x) =&gt; &#123; if (arr1.indexOf(x) == -1) &#123; arr1.push(x) &#125; &#125;) return arr1;&#125; 4. 还是利用 indexOf() (原理有差别)原理: 查找数组里面的每一项,看其下标是否对应.12345678910111213141516171819202122232425262728293031323334353637383940 Array.prototype.removal_four = function () &#123; let arr1 = []; this.reduce((prev, now, index, arr) =&gt; &#123; if( arr.indexOf(now) == index ) &#123; arr1.push( now ) &#125; &#125;,this[0]) return arr1; &#125; //reduce() ES6新增方法. 二个参数: //第一个参数接收一个函数 其接收四个参数: // 第一个参数(prev) =&gt; 前一个值 // 第二个参数(now) =&gt; 当前值 // 第三个参数(index) =&gt; 当前值的索引 // 第四个参数(arr) =&gt; 当前值的数组 //第二个参数接收一个默认值,对应prev(起始值)// 不接收第二个参数 var arr = [1,2,3,4,5,6]; arr.reduce((prev, now, index, arr)=&gt;&#123; console.log(prev,now) &#125;) //1 2 //undefined 3 //undefined 4 //undefined 5 //undefined 6 // 接收第二个参数 var arr1 = [1,2,3,4,5,6]; arr.reduce((prev, now, index, arr)=&gt;&#123; console.log(prev,now) &#125;,0) //0 1 //undefined 3 //undefined 4 //undefined 5 //undefined 6 5. ES6 set() 12let arr1 = [1,2,3,1,2,6,4,8,4,5,6];let arr = new set(arr1)]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 请看下面的代码。 123456789101112131415161718192021 function f1()&#123; var num = 99; add = function () &#123; num++ &#125; // 这里没有使用 var add被注册为全局变量 function f2() &#123; alert(num); // 调用父函数变量 num &#125; return f2; &#125; var result = f1(); // f1返回f2函数, f2被赋给了一个全局变量，这导致f2始终在内存中 result(); // 99 add(); // num++ result(); // 100 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是99，第二次的值是100。这证明了，函数f1中的局部变量num一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是add=function(){num+=1}这一行，首先在add前面没有使用var关键字，因此add是一个全局变量，而不是局部变量。其次，add的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以add相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。]]></content>
      <tags>
        <tag>闭包</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无具体宽高元素水平垂直居中]]></title>
    <url>%2Fcss-center%2F</url>
    <content type="text"><![CDATA[居中效果在CSS中很是普通的效果，平时大家所看到的居中效果主要分为三大类：水平居中、垂直居中和水平垂直居中。而其中水平居中相对于后两者来说要简单得. 水平居中 1. 浮动 12345678910&lt;style media="screen" type="text/css"&gt; .wrap&#123;position:relative;left:50%; float:left;&#125; .cont&#123;position:relative;left:-50%;&#125;&lt;/style&gt;&lt;div class="wrap"&gt; &lt;div class="cont"&gt; 没有宽度的div实现水平居中显示 &lt;/div&gt;&lt;/div&gt; 原理:先让元素左浮动 父元素的左边距页面的左边为0,设置父元素的position:relative;left:50%;后 父元素的左边距页面的左边为50%.此时子元素的左边距页面的左边也是50%, 这时如果设置子元素的position:relative;left:-50%; 或者 position:relative;right:50%;子元素都会像左边移动50%的距离.(此时的50%是页面的25%) 2. 定位 12345678910111213&lt;style media="screen" type="text/css"&gt; .con &#123;position: relative;&#125; .wrap&#123;position: absolute;left:50%;&#125; .cont&#123;position: relative;left:-50%;&#125;&lt;/style&gt;&lt;div class="con"&gt; &lt;div class="wrap"&gt; &lt;div class="cont"&gt; 没有宽度的div实现水平居中显示 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 原理: 与方法1 一样 3. display: box 12345678910111213141516171819202122&lt;style media="screen" type="text/css"&gt; .cont &#123; display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-pack: center; display: -moz-box; -moz-box-orient: horizontal; -moz-box-pack: center; display: -o-box; -o-box-orient: horizontal; -o-box-pack: center; display: -ms-box; -ms-box-orient: horizontal; -ms-box-pack: center; display: box; box-orient: horizontal; box-pack: center; &#125;&lt;/style&gt;&lt;div class="cont"&gt; 没有宽度的div实现水平居中显示&lt;/div&gt; 4. fit-content 12345678910111213&lt;style media="screen" type="text/css"&gt; .cont&#123; width: -moz-fit-content; width:-webkit-fit-content; width: fit-content; margin-left: auto; margin-right: auto; &#125;&lt;/style&gt;&lt;div class="cont"&gt; 没有宽度的div实现水平居中显示&lt;/div&gt; 5. display: table 12345678910&lt;style media="screen" type="text/css"&gt; .cont&#123; display: table; margin: auto; &#125;&lt;/style&gt;&lt;div class="cont"&gt; 没有宽度的div实现水平居中显示&lt;/div&gt; 垂直居中 1. 方法一 12345678910111213141516.cont &#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; height: 220px; width: 70%; background: red;&#125;&lt;div class="cont"&gt; 垂直居中显示 需要设置宽度,高度&lt;/div&gt; 2. 方法二 12345678910111213.cont &#123; width: 70%; height: 200px; position: absolute; top: 50%; margin-top: -100px; background: red;&#125;&lt;div class="cont"&gt; 垂直居中显示 需要设置宽度,高度&lt;/div&gt; 3. 方法三 12345678910.cont &#123; position: absolute; top:50%; transform:translateY(-50%);&#125;&lt;div class="cont"&gt; 垂直居中显示 无需宽高 &lt;/div&gt; 4. 方法四 123456789101112.wrap&#123; display: flex; align-items:center;&#125;.cont&#123;margin: auto;&#125;&lt;div class="wrap"&gt; &lt;div class="cont"&gt; 没有宽度 &lt;/div&gt;&lt;/div&gt; 水平垂直居中 1. 方法一 1234567891011121314.cont &#123; width: 50%; height: 50%; background: #000; /* overflow: auto; */ margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0; &#125;&lt;div class="cont"&gt; 垂直居中显示 需宽高&lt;/div&gt; 2. 方法二 1234567891011.cont &#123; position: absolute; top:50%; left:50%; transform:translate(-50%,-50%);&#125;&lt;div class="cont"&gt; 垂直居中显示 无需宽高 &lt;/div&gt;]]></content>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node(express) + mysql 实现模糊查询]]></title>
    <url>%2Fnode-mysql%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[Node + express + mysql + Navicat for mysql 实现模糊查询 仓库地址 -&gt; 点击这里 话不多说直接上代码..app.js12345678910111213141516171819202122232425262728293031323334353637383940const express = require(&apos;express&apos;);// const bodyparser = require(&apos;body-parser&apos;);const mysql = require(&apos;mysql&apos;);const app = express();const router = express.Router();app.use(express.urlencoded(&#123;&#125;));let pool = mysql.createPool(&#123; host:&apos;localhost&apos;, user:&apos;root&apos;, password:&apos;root&apos;, database:&apos;query&apos;, port:3306&#125;)// 设置为可跨域app.all(&apos;*&apos;, function(req, res, next) &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); res.header(&quot;X-Powered-By&quot;,&apos; 3.2.1&apos;) res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); next();&#125;);//这里是 /login 前端请求地址为 http://localhost:8001/loginapp.get(&apos;/login&apos;,(req,res)=&gt;&#123; var value = req.query.val; pool.query(`SELECT * FROM students where name like &apos;%$&#123;value&#125;%&apos;`, (qerr,vals,fields)=&gt;&#123; let rows = JSON.stringify(vals); res.send(rows) &#125;) &#125;)app.use(express.static(&apos;./&apos;))app.listen(8001,() =&gt; &#123; console.log(&apos;ok&apos;);&#125;)]]></content>
      <tags>
        <tag>Node</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node+mySQL接口]]></title>
    <url>%2Fnode-mySQL%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[数据库Navicat for mysql 建表写入数据 node.jsapp.js12345678910111213141516171819202122232425262728293031323334const express = require('express');const mysql = require('mysql');const app = express();//建立连接const pool = mysql.createPool(&#123; host:'localhost', user:'root', password:'123456', database:'dataBaseName', port:3306&#125;)// 设置为可跨域app.all('*', function(req, res, next) &#123; res.header("Access-Control-Allow-Origin", "*"); res.header("Access-Control-Allow-Headers", "X-Requested-With"); res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS"); res.header("X-Powered-By",' 3.2.1') res.header("Content-Type", "application/json;charset=utf-8"); next();&#125;);// 前端请求地址为 http://localhost:8001/loginapp.get('/login',(req,res)=&gt;&#123; pool.query(`SELECT * FROM login`, (qerr,vals,fields)=&gt;&#123; let rows = JSON.stringify(vals); res.send(rows) &#125;) &#125;)app.listen(8001,() =&gt; &#123; console.log('ok');&#125;)]]></content>
      <tags>
        <tag>Node</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Small program - config]]></title>
    <url>%2FsmallProgram%2F</url>
    <content type="text"><![CDATA[配置app.json文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。以下是一个包含了所有配置选项的 app.json ：1234567891011121314151617181920212223&#123; &quot;pages&quot;: [ &quot;pages/index/index&quot;, &quot;pages/logs/index&quot; ], &quot;window&quot;: &#123; &quot;navigationBarTitleText&quot;: &quot;Demo&quot; &#125;, &quot;tabBar&quot;: &#123; &quot;list&quot;: [&#123; &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/logs/logs&quot;, &quot;text&quot;: &quot;日志&quot; &#125;] &#125;, &quot;networkTimeout&quot;: &#123; &quot;request&quot;: 10000, &quot;downloadFile&quot;: 10000 &#125;, &quot;debug&quot;: true&#125; app.json 配置项列表 属性 类型 必填 描述 pages String Array 是 设置页面路径 window Object 否 设置默认页面的窗口表现 tabBar Object 否 设置底部 tab 的表现 networkTimeout Object 否 设置网络超时时间 debug String Array 否 设置是否开启 debug 模式 pages接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息， 数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改 文件名不需要写文件后缀，因为框架会自动去寻找路径下 .json, .js, .wxml, .wxss 四个文件进行整合。 如开发目录为： pages/ index/ index.wxml index.js index.wxss logs/ logs.wxml logs.js app.jsapp.jsonapp.wxss 则需要在 app.json 中写123456&#123; &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ]&#125; window用于设置小程序的状态栏、导航条、标题、窗口背景色。 属性 类型 默认值 描述 最低版本 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如”#000000” navigationBarTextStyle String white 导航栏标题颜色，仅支持 black/white navigationBarTitleText String 导航栏标题文字内容 navigationStyle String default 导航栏样式，仅支持 default/custom。custom 模式可自定义导航栏，只保留右上角胶囊状的按钮 微信版本 6.6.0 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark/light backgroundColorTop String #ffffff 顶部窗口的背景色，仅 iOS 支持 微信版本 6.5.16 backgroundColorBottom String #ffffff 底部窗口的背景色，仅 iOS 支持 微信版本 6.5.16 enablePullDownRefresh Boolean false 是否开启下拉刷新，详见页面相关事件处理函数 onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px 注：HexColor（十六进制颜色值），如”#ff00ff” 注：navigationStyle 只在 app.json 中生效。开启 custom 后，低版本客户端需要做好兼容。开发者工具基础库版本切到 1.7.0（不代表最低版本，只供调试用） 可方便切到旧视觉 如 app.json ：123456789&#123; &quot;window&quot;:&#123; &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot; &#125;&#125; tabBar如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面 Tip： 当设置 position 为 top 时，将不会显示 icon tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 属性说明： 属性 类型 必填 默认值 描述 color HexColor 是 tab 上的文字默认颜色 selectedColor HexColor 是 tab 上的文字选中时的颜色 backgroundColor HexColor 是 tab 的背景色 borderStyle String 否 black tabbar上边框的颜色， 仅支持 black/white list Array 是 tab 的列表，详见 list 属性说明，最少2个、最多5个 tab position String 否 bottom 可选值 bottom、top 其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下： 属性 类型 必填 说明 pagePath String 是 页面路径，必须在 pages 中先定义 text String 是 tab 上按钮文字 iconPath String 否 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效，不支持网络图片 selectedIconPath String 否 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 networkTimeout可以设置各种网络请求的超时时间。 属性说明: 属性 类型 必填 说明 request Number 否 wx.request的超时时间，单位毫秒，默认为：60000 connectSocket Number 否 wx.connectSocket的超时时间，单位毫秒，默认为：60000 uploadFile Number 否 wx.uploadFile的超时时间，单位毫秒，默认为：60000 downloadFile Number 否 wx.downloadFile的超时时间，单位毫秒，默认为：60000 debug可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有Page的注册， 页面路由， 数据更新， 事件触发。 可以帮助开发者快速定位一些常见的问题。 page.json每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 页面的.json只能设置 window 相关的配置项，以决定本页面的窗口表现，所以无需写 window 这个键，如： 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如”#000000” navigationBarTextStyle String white 导航栏标题颜色，仅支持 black/white navigationBarTitleText String 导航栏标题文字内容 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark/light enablePullDownRefresh Boolean false 是否开启下拉刷新，详见页面相关事件处理函数。 disableScroll Boolean false 设置为 true 则页面整体不能上下滚动；只在 page.json 中有效，无法在 app.json 中设置该项 onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px 1234567&#123; &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot;&#125;]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给 Hexo Next 添加统计]]></title>
    <url>%2F%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[NexT 主题默认已经集成了文章【字数统计】、【阅读时长】统计功能，如果我们需要使用，只需要在主题配置文件 _config.yml 中打开 wordcount 统计功能即可。如果没有安装 hexo-wordcount 插件，先安装该插件：npm i --save hexo-wordcount然后:12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计 min2read: true # 单篇 阅读时长 totalcount: false # 网站 字数统计 separated_meta: true]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[attr prop 区别]]></title>
    <url>%2FattrAndProp%2F</url>
    <content type="text"><![CDATA[jquery中attr和prop的区别在高版本的jquery引入prop方法后，什么时候该用prop？什么时候用attr？它们两个之间有什么区别？这些问题就出现了。 对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。 举几个例子就知道了。 1&lt;a href="http://www.baidu.com" target="_self" class="btn"&gt;百度&lt;/a&gt; 这个例子里&lt;a&gt;元素的DOM属性有“href、target和class“，这些属性就是&lt;a&gt;元素本身就带有的属性，也是W3C标准里就包含有这几个属性，或者说在IDE里能够智能提示出的属性，这些就叫做固有属性。处理这些属性时，建议使用prop方法。 1&lt;a href="#" id="link1" action="delete"&gt;删除&lt;/a&gt; 这个例子里&lt;a&gt;元素的DOM属性有“href、id和action”，很明显，前两个是固有属性，而后面一个“action”属性是我们自己自定义上去的，&lt;a&gt;元素本身是没有这个属性的。这种就是自定义的DOM属性。处理这些属性时，建议使用attr方法。使用prop方法取值和设置属性值时，都会返回undefined值。 再举一个例子： 12&lt;input id="chk1" type="checkbox" /&gt; //是否可见&lt;input id="chk2" type="checkbox" checked="checked" /&gt; //是否可见 像checkbox，radio和select这样的元素，选中属性对应“checked”和“selected”，这些也属于固有属性，因此需要使用prop方法去操作才能获得正确的结果。 12$("#chk1").prop("checked") == false$("#chk2").prop("checked") == true 如果上面使用attr方法，则会出现： 12$("#chk1").attr("checked") == undefined$("#chk2").attr("checked") == "checked"]]></content>
      <tags>
        <tag>JQuery</tag>
        <tag>attr</tag>
        <tag>prop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 跨域]]></title>
    <url>%2FkuaYu%2F</url>
    <content type="text"><![CDATA[首先要知道什么是跨域！ 跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。 所谓同源是指，域名，协议，端口均相同，不明白没关系，举个栗子： 123456789101112http://www.123.com/index.html 调用 http://www.123.com/server.php （非跨域）http://www.123.com/index.html 调用 http://www.456.com/server.php （主域名不同:123/456，跨域）http://abc.123.com/index.html 调用 http://def.123.com/server.php （子域名不同:abc/def，跨域）http://www.123.com:8080/index.html 调用 http://www.123.com:8081/server.php （端口不同:8080/8081，跨域）http://www.123.com/index.html 调用 https://www.123.com/server.php （协议不同:http/https，跨域）请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。 浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。 使用JSONP进行跨域请求！1234567var script = document.createElement("script");script.src = "https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse";document.body.insertBefore(script, document.body.firstChild);function handleResponse(response)&#123; // 对response数据进行操作代码 console.log(response)&#125; jsonp原理：其本质是利用了标签的src属性具有可跨域的特性，由服务端返回预先定义好的javascript函数的调用，并且将服务端数据以该函数参数的形式传递过来。 使用JQuery $.ajax()进行请求12345678910111213141516$.ajax(&#123; async : true, url : "https://api.douban.com/v2/book/search", type : "GET", dataType : "jsonp", // 返回的数据类型，设置为JSONP方式 jsonp : 'callback', //指定一个查询参数名称来覆盖默认的 jsonp 回调参数名 callback jsonpCallback: 'handleResponse', //设置回调函数名 data : &#123; q : "javascript", count : 1 &#125;, success: function(response, status, xhr)&#123; console.log('状态为：' + status + ',状态是：' + xhr.statusText); console.log(response); &#125;&#125;); 使用 $.getJSON()进行请求在路径后加 ‘？callback=？’ 即可123$.getJSON("https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=?", function(data)&#123; console.log(data);&#125;); ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加标签来调用服务器提供的js脚本。 ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 *本文参考https://blog.csdn.net/u014607184/article/details/52027879]]></content>
      <tags>
        <tag>AJAX</tag>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 Array扩展]]></title>
    <url>%2Fes6%E6%96%B0%E5%A2%9Earray%2F</url>
    <content type="text"><![CDATA[find : 1234567let arr=[1,2,234,&apos;sdf&apos;,-2];arr.find(function(x)&#123; return x&lt;=2;&#125;)//结果：1，返回第一个符合条件的x值arr.find(function(x,i,arr)&#123; if(x&lt;2)&#123;console.log(x,i,arr)&#125;&#125;)//结果：1 0 [1, 2, 234, &quot;sdf&quot;, -2]，-2 4 [1, 2, 234, &quot;sdf&quot;, -2] find的参数为回调函数，回调函数可以接收3个参数，值x、索引i、数组arr，回调函数默认返回值x。 findIndex :1234567let arr=[1,2,234,&apos;sdf&apos;,-2];arr.findIndex(function(x)&#123; return x&lt;=2;&#125;)//结果：0，返回第一个符合条件的x值的索引arr.findIndex(function(x,i,arr)&#123; if(x&lt;2)&#123;console.log(x,i,arr)&#125;&#125;)//结果：1 0 [1, 2, 234, &quot;sdf&quot;, -2]，-2 4 [1, 2, 234, &quot;sdf&quot;, -2] findIndex和find差不多，不过默认返回的是索引。 includes :1234let arr=[1,2,234,&apos;sdf&apos;,-2];arr.includes(2);// 结果true，返回布尔值arr.includes(20);// 结果：false，返回布尔值arr.includes(2,3)//结果：false，返回布尔值 includes函数与string的includes一样，接收2参数，查询的项以及查询起始位置。 keys :1234let arr=[1,2,234,&apos;sdf&apos;,-2];for(let a of arr.keys())&#123; console.log(a)&#125;//结果：0,1,2,3,4 遍历了数组arr的索引 keys，对数组索引的遍历 values :1234let arr=[1,2,234,&apos;sdf&apos;,-2];for(let a of arr.values())&#123; console.log(a)&#125;//结果：1,2,234,sdf,-2 遍历了数组arr的值 values，对数组项的遍历 entries :1234567let arr=[&apos;w&apos;,&apos;b&apos;];for(let a of arr.entries())&#123; console.log(a)&#125;//结果：[0,w],[1,b]for(let [i,v] of arr.entries())&#123; console.log(i,v)&#125;//结果：0 w,1 b entries，对数组键值对的遍历。 fill :1234let arr=[&apos;w&apos;,&apos;b&apos;];arr.fill(&apos;i&apos;)//结果：[&apos;i&apos;,&apos;i&apos;]，改变原数组arr.fill(&apos;o&apos;,1)//结果：[&apos;i&apos;,&apos;o&apos;]改变原数组,第二个参数表示填充起始位置new Array(3).fill(&apos;k&apos;).fill(&apos;r&apos;,1,2)//结果：[&apos;k&apos;,&apos;r&apos;,&apos;k&apos;]，第三个数组表示填充的结束位置 fill方法改变原数组，当第三个参数大于数组长度时候，以最后一位为结束位置。 Array.of() :1234Array.of(&apos;w&apos;,&apos;i&apos;,&apos;r&apos;)//[&quot;w&quot;, &quot;i&quot;, &quot;r&quot;]返回数组Array.of([&apos;w&apos;,&apos;o&apos;])//[[&apos;w&apos;,&apos;o&apos;]]返回嵌套数组Array.of(undefined)//[undefined]依然返回数组Array.of()//[]返回一个空数组 Array.of()方法永远返回一个数组，参数不分类型，只分数量，数量为0返回空数组。 copyWithin :1234[&quot;w&quot;, &quot;i&quot;, &quot;r&quot;].copyWithin(0)//此时数组不变[&quot;w&quot;, &quot;i&quot;, &quot;r&quot;].copyWithin(1)//[&quot;w&quot;, &quot;w&quot;, &quot;i&quot;],数组从位置1开始被原数组覆盖，只有1之前的项0保持不变[&quot;w&quot;, &quot;i&quot;, &quot;r&quot;,&quot;b&quot;].copyWithin(1,2)//[&quot;w&quot;, &quot;r&quot;, &quot;b&quot;, &quot;b&quot;],索引2到最后的r,b两项分别替换到原数组1开始的各项，当数量不够，变终止[&quot;w&quot;, &quot;i&quot;, &quot;r&quot;,&apos;b&apos;].copyWithin(1,2,3)//[&quot;w&quot;, &quot;r&quot;, &quot;r&quot;, &quot;b&quot;]，强第1项的i替换为第2项的r copyWithin方法接收三个参数，被替换数据的开始处、替换块的开始处、替换块的结束处(不包括);copyWithin(s,m,n). Array.from() :12345678910Array.from(&#123;&apos;0&apos;:&apos;w&apos;,&apos;1&apos;:&apos;b&apos;,length:2&#125;)//[&quot;w&quot;, &quot;b&quot;],返回数组的长度取决于对象中的length，故此项必须有！Array.from(&#123;&apos;0&apos;:&apos;w&apos;,&apos;1&apos;:&apos;b&apos;,length:4&#125;)//[&quot;w&quot;, &quot;b&quot;, undefined, undefined],数组后2项没有属性去赋值，故undefinedArray.from(&#123;&apos;0&apos;:&apos;w&apos;,&apos;1&apos;:&apos;b&apos;,length:1&#125;)//[&quot;w&quot;],length小于key的数目，按序添加数组//////////////////////////////let divs=document.getElementsByTagName(&apos;div&apos;);Array.from(divs)//返回div元素数组Array.from(&apos;wbiokr&apos;)//[&quot;w&quot;, &quot;b&quot;, &quot;i&quot;, &quot;o&quot;, &quot;k&quot;, &quot;r&quot;]Array.from([1,2,3],function(x)&#123; return x+1&#125;)//[2, 3, 4],第二个参数为回调函数 Array.from可以把带有lenght属性类似数组的对象转换为数组，也可以把字符串等可以遍历的对象转换为数组，它接收2个参数，转换对象与回调函数]]></content>
      <tags>
        <tag>Array</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String字符串方法]]></title>
    <url>%2FString%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. charAt()1str.charAt(n) 返回字符串的第 n 个字符，如果不在 0~str.length-1之间，则返回一个空字符串。 2. indexOf()1indexOf(substr[,start]) 返回 substr 在字符串 str 中首次出现的位置,从 start 位置开始查找，如果不存在，则返回 -1。 start可以是任意整数，默认值为 0。如果 start &lt; 0 则查找整个字符串（如同传进了 0）。如果 start &gt;= str.length，则该方法返回 -1，除非被查找的字符串是一个空字符串，此时返回 str.length.12345var str = &quot;javascript&quot;;str.indexOf(&apos;s&apos;); // 1str.indexOf(&apos;s&apos;,6); // -1str.indexOf(&apos;&apos;,11); // 10str.indexOf(&apos;&apos;,8); // 8 3. lastIndexOf()1lastIndexOf(substr[,start]) 返回 substr 在字符串 str 中最后出现的位置,从 start 位置 向前开始查找，如果不存在，则返回 -1。1&apos;lastindex&apos;.lastIndexOf(&apos;a&apos;); // 1 4. substring()1str.substring(start[, end]) 返回从 start 到 end（不包括）之间的字符，start、end均为 非负整数。若结束参数(end)省略，则表示从start位置一直截取到最后。1234var str = &apos;abcdefg&apos;;str.substring(1, 4); //&quot;bcd&quot;str.substring(1); // &quot;bcdefg&quot;str.substring(-1); //&quot;abcdefg&quot; 传入负值时会视为0 5. slice()1str.slice(start[,end]) 返回从 start 到 end （不包括）之间的字符，可传负值12var str = &apos;this is awesome&apos;;str.slice(4, -1); //&quot; is awesom&quot; 6. substr()1str.slice(start[,end]) 返回 str 中从指定位置开始到指定长度的子字符串，start可为负值 123var str = &quot;Just give me a reason&quot;;str.substr(5, 10); // &quot;give me a &quot;str.substr(-4, 2); // &quot;as&quot; 7.replace()1str.replace(regexp|substr, newSubStr|function) 替换 str 的子字符串12var str = &quot;do you love me&quot;;str.replace(&apos;love&apos;,&apos;hate&apos;); // &quot;do you hate me&quot; 8. search()1str.search(regexp) 查找 str 与一个正则表达式是否匹配。如果匹配成功，则返回正则表达式在字符串中首次匹配项的索引；否则，返回 -1。如果参数传入的是一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象12345var str = &apos;I love JavaScript!&apos;;str.search(/java/); // -1str.search(/Java/); // 7str.search(/java/i); // 7str.search(&apos;Java&apos;); // 7 9. match()1str.match(regexp) 返回一个包含匹配结果的数组，如果没有匹配项，则返回 null。如果参数传入的是一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象1234var str = &apos;Javascript java&apos;;str.match(/Java/); // [&quot;Java&quot;]str.match(/Java/gi); // [&quot;java&quot;, &quot;Java&quot;]str.match(/ab/g); // null 10. split()1str.split([separator][, limit]) 返回一个数组，分隔符 separator 可以是一个字符串或正则表达式12345var str = &quot;Hello?World!&quot;;str.split(); // [&quot;Hello?World!&quot;]str.split(&apos;&apos;); // [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot;?&quot;, &quot;W&quot;, &quot;o&quot;, &quot;r&quot;, &quot;l&quot;, &quot;d&quot;, &quot;!&quot;]str.split(&apos;?&apos;); // [&quot;Hello&quot;, &quot;World!&quot;]str.split(&apos;&apos;,5); // [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;] 11. trim()1str.trim() 去除 str 开头和结尾处的空白字符，返回 str 的一个副本，不影响字符串本身的值123var str = &apos; abc &apos;;str.trim(); // &apos;abc&apos;console.log(str); // &apos; abc &apos; 12. toLowerCase()1str.toLowerCase() 将 str 转换为小写，并返回 str 的一个副本，不影响字符串本身的值123var str = &apos;JavaScript&apos;;str.toLowerCase(); // &apos;javascript&apos;console.log(str); // &apos;JavaScript&apos; 13. toUpperCase()1str.toUpperCase() 将 str 转换为大写，并返回 str 的一个副本，不影响字符串本身的值123var str = &apos;JavaScript&apos;;str.toUpperCase(); // &apos;JAVASCRIPT&apos;console.log(str); // &apos;JavaScript&apos;]]></content>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6新增语法]]></title>
    <url>%2FES6%E6%96%B0%E5%A2%9E%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[let,constlet命令的用法类似于var，用来声明变量。可以把let看成var，只是它定义的变量被限定在了特定范围内才能使用，而离开这个范围则无效。123456&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。12const PI = Math.PIPI = 23 //Module build failed: &quot;PI&quot; is read-only class 定义 类类实际上是个“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：类表达式和类声明 类声明定义一个类的一种方法是使用一个类声明。要声明一个类，你可以使用带有class关键字的类名（这里是“Rectangle”）。123456class Rectangle &#123; constructor(height, width) &#123; this.height = height; this.width = width; &#125;&#125; 箭头函数ES6允许使用“箭头”（=&gt;）定义函数1234567var f = v =&gt; v;//上面的箭头函数等于:var f = function(v)&#123; return v;&#125; 箭头函数除了能简化代码，还有更大的好处：减少this的使用。箭头函数内部没有constructor方法，也没有prototype，所以不支持new操作。但是它对this的处理与一般的普通函数不一样。 箭头函数的 this 始终指向函数定义时的 this，而非执行时。 例如:1234567891011var o = &#123; x : 1, func : function() &#123; console.log(this.x) &#125;, test : function() &#123; setTimeout(function() &#123; this.func(); &#125;, 100); &#125;&#125;;o.test(); // TypeError : this.func is not a function 上面的代码会出现错误，因为this的指向从o变为了全局（函数调用中的this都是指向全局的）。我们需要使用外部变量事先保存this，修改上面的代码如下：123456789101112var o = &#123; x : 1, func : function() &#123; console.log(this.x) &#125;, test : function() &#123; var _this = this; setTimeout(function() &#123; _this.func(); &#125;, 100); &#125;&#125;;o.test(); 这段代码如果使用箭头函数，就不需要使用this，因为箭头函数的 this 始终指向函数定义时的 this，而非执行时。所以我们将上面的代码修改如下：123456789var o = &#123; x : 1, func : function() &#123; console.log(this.x) &#125;, test : function() &#123; setTimeout(() =&gt; &#123; this.func() &#125;, 100); &#125;&#125;;o.test(); 字符串模板（反引号 `）ES6中提供了用反引号｀来创建字符串，里面可包含${…}，即在字符串中可以添加变量12let name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` rest, spread扩展运算符（ spread ）和Rest操作符都是用三个点（…）表示，但作用整好相反。Rest操作符一般用在函数参数的声明中，而扩展运算符用在函数的调用中。1234function func(...args)&#123; console.log(args);//[1,2,3,4]&#125;func(1,2,3,4); for…offor…of(这里先记录一下之后在深入了解一下)1234let arr = [1,2,3];for (let itr of arr) &#123; console.log(itr); //1 2 3&#125; Map, Set(依然是先做记录之后深入了解)ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。12345四个操作方法：add(value)：添加某个值，返回Set结构本身。delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。has(value)：返回一个布尔值，表示该值是否为Set的成员。clear()：清除所有成员，没有返回值 Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 12345678//实例属性和方法：size、set、get、has、delete、clearlist = supportList.map( (item,index) =&gt; &lt;option key=&#123;item.a&#125; value=&#123;item.b&#125;&gt; &#123;item.c&#125; &lt;/option&gt; ); Symbols(目前我也不知道是做什么用的,先记录一下吧!)Symbol 是一种新的数据类型，它的值是唯一的，不可变的。ES6 中提出 symbol 的目的是为了生成一个唯一的标识符，不过你访问不到这个标识符.12var sym = Symbol( &quot;Symbol&quot; );console.log(typeof sym); // symbol 如果要获取对象 symbol 属性，需要使用Object.getOwnPropertySymbols(o) Iterators（迭代器）(先记录,之后深入了解一下)ES6 中可以通过 Symbol.iterator 给对象设置默认的遍历器，直到状态为true退出。1234567var arr = [11,12,13];var itr = arr[Symbol.iterator]();itr.next(); //&#123; value: 11, done: false &#125;itr.next(); //&#123; value: 12, done: false &#125;itr.next(); //&#123; value: 13, done: false &#125;itr.next(); //&#123; value: undefined, done: true &#125; 解构(值得深入了解一下…)解构赋值是ES6中推出的一种高效、简洁的赋值方法123456789101112//通常情况下var arr = [1,2,3];var first = arr[0];var two = arr[1];var three = arr[2];//解构赋值let [first, two, three] = arr;//first = 1;//two = 2;//three = 3;]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之字符串扩展方法(常用)]]></title>
    <url>%2FES6%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95(%E5%B8%B8%E7%94%A8)%2F</url>
    <content type="text"><![CDATA[includesincludes是判断是否包含的,直接返回布尔值1234567let str=&apos;google&apos;;if(str.includes(&apos;o&apos;))&#123; console.log(&apos;yes&apos;);&#125;else&#123; console.log(&apos;no&apos;);&#125; startsWith ，endsWithstartsWith用于判断是否位于头部，endsWith判断是否位于尾部，可以说这两个方法是includes方法的扩展；12345let str=&apos;google&apos;;console.log(str.startsWith(&apos;g&apos;)); //trueconsole.log(str.endsWith(&apos;e&apos;)); //true repeat顾名思义，这个方法就是可以获取字符串重复N次后的方法；12let str=&apos;google&apos;;console.log(str.repeat(3)); //googlegooglegoogle repeat方法接受一个数字类型的参数，可以是正式也可以是小数，如果是浮点型会自动调用Math.floor方法转为整型；123let str=&apos;google&apos;;console.log(str.repeat(3.5)); //googlegooglegoogleconsole.log(str.repeat(Math.floor(3.5)));//googlegooglegoogle 参数可以为0这样就会返回一个空字符串，但是不能为负数，否则会报错；123let str=&apos;google&apos;;console.log(str.repeat(0)); //&apos;&apos;console.log(str.repeat(-3.5));//RangeError: Invalid count value padStart,padEnd这两个方法其实是ES7标准下扩展的方法，作用就是自动补全；12345let str=&apos;goo&apos;;&lt;br&gt; str.padStart(5, &apos;le&apos;) // &apos;legoo&apos;str.padStart(4, &apos;le&apos;) // &apos;lgoo&apos;str.padEnd(5, &apos;le&apos;) // &apos;goole&apos;str.padEnd(4, &apos;le&apos;) // &apos;gool&apos; 这两个方法类似都是接受两个参数，第一个是补全的长度，第二个是要补充的内容，由于是es7标准的方法，现在浏览器还不能直接运行，可以尝试借助babel运行；]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2FAjax%2F</url>
    <content type="text"><![CDATA[ajax 的全称是Asynchronous JavaScript and XML，其中，Asynchronous 是异步的意思，它有别于传统web开发中采用的同步的方式。 ajax原理和XmlHttpRequest对象 Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。 XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。 首先，我们先来看看XMLHttpRequest这个对象的属性。 它的属性有： onreadystatechange 每次状态改变所触发事件的事件处理程序。 responseText 从服务器进程返回数据的字符串形式。 responseXML 从服务器进程返回的DOM兼容的文档数据对象。 status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪） status Text 伴随状态码的字符串信息 readyState 对象状态值 0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法） 1 (初始化) 对象已建立，尚未调用send方法 2 (发送数据) send方法已调用，但是当前的状态及http头未知 3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误， 4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据 但是，由于各浏览器之间存在差异，所以创建一个XMLHttpRequest对象可能需要不同的方法。这个差异主要体现在IE和其它浏览器之间。下面是一个比较标准的创建XMLHttpRequest对象的方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//创建传输对象function createXHR()&#123; if(window.XMLHttpRequest)&#123; return new XMLHrrpRequest(); &#125; return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;//obj &#123;name:huhu,age:18&#125; =&gt; &quot;name=huhu&amp;age=18&quot;//格式化参数function params(obj) &#123; var arr = []; for(var i in obj) &#123; var str = i + &quot;=&quot; + obj[i]; arr.push(str); &#125; arr.push((&quot;v=&quot; + Math.random()).replace(&quot;.&quot;, &quot;&quot;)); return arr.join(&quot;&amp;&quot;);&#125;function ajax(option)&#123; option = option || &#123;&#125;; option.url = option.url || &apos;&apos;; option.type = option.type.toUpperCase() || &apos;GET&apos;; option.data = option.data || &apos;&apos;; option.async = option.async || true; option.success = option.success || function (data) &#123;&#125;; option.error = option.errro || function (data) &#123;&#125;; // 第一步 创建对象 var xhr = createXHR(); //连接 和 发送 - 第二步 if (option.type == &quot;GET&quot;) &#123; xhr.open(&quot;GET&quot;, option.url + &quot;?&quot; + params(option.data), option.async); xhr.send(null); &#125; else if (option.type == &quot;POST&quot;) &#123; xhr.open(&quot;POST&quot;, option.url, option.async); //设置表单提交时的内容类型 xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.send(params(option.data)); &#125;else&#123; alert(&apos;类型有误&apos;) return; &#125; xhr.onreadystatechange = function () &#123; if (XHR.readyState == 4) &#123; var status = xhr.status; if (XHR.status &gt;= 200 &amp;&amp; XHR.status &lt; 300 || XHR.status == 304) &#123; switch (obj.responseType) &#123; case &apos;document&apos;: obj.success(XHR.responseXML); break; case &apos;json&apos;: obj.success(XHR.response); break; default: obj.success(XHR.responseText); break; &#125; &#125;else&#123; option.error(status); &#125; &#125; &#125;&#125;/* 使用 ajax(&#123; type:请求的方式 get/post 如果省略 默认是get, url:不能省略 必须参数 服务器地址, data:&#123;&#125; 参数 如果没有参数省略即可, async: ture/false 是否是异步 默认不写就是异步, success:function(data)&#123;&#125; 请求成功的回调函数 data表示请求回来的数据, error:function(data)&#123;&#125; 请求失败的回调函数, responseType:document(请求xml数据) json(请求json数据) text 如果省略默认返回text &#125;);*/ 还有其他封装方法 不一一列出了~ Ajax的缺点下面所阐述的ajax的缺陷都是它先天所产生的。 1、ajax干掉了back按钮，即对浏览器后退机制的破坏。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来取消前一次操作的。那么对于这个问题有没有办法？答案是肯定的，用过Gmail的知道，Gmail下面采用的ajax技术解决了这个问题，在Gmail下面是可以后退的，但是，它也并不能改变ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。） 但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，和ajax框架所要求的快速开发是相背离的。这是ajax所带来的一个非常严重的问题。 2、安全问题 技术同时也对IT企业带来了新的安全威胁，ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。 3、对搜索引擎的支持比较弱。 4、破坏了程序的异常机制。至少从目前看来，像ajax.dll，ajaxpro.dll这些ajax框架是会破坏程序的异常机制的。关于这个问题，我曾经在开发过程中遇到过，但是查了一下网上几乎没有相关的介绍。后来我自己做了一次试验，分别采用ajax和传统的form提交的模式来删除一条数据……给我们的调试带来了很大的困难。 5、另外，像其他方面的一些问题，比如说违背了url和资源定位的初衷。例如，我给你一个url地址，如果采用了ajax技术，也许你在该url地址下面看到的和我在这个url地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。 6、一些手持设备（如手机、PDA等）现在还不能很好的支持ajax，比如说我们在手机的浏览器上打开采用ajax技术的网站时，它目前是不支持的，当然，这个问题和我们没太多关系。]]></content>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class 类--初识]]></title>
    <url>%2FClass-%E7%B1%BB-%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[类的声明定义一个类的一种方法是使用一个类声明。要声明一个类，你可以使用带有class关键字的类名 123456class Remou &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; &#125; 不存在变量提升类不存在变量提升（hoist），这一点与 ES5 完全不同。 12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。 12345&#123; let Foo = class &#123;&#125;; class Bar extends Foo &#123; &#125;&#125; 上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。 类的表达式一个 类表达式 是定义一个类的另一种方式。类表达式可以是被命名的或匿名的。赋予一个命名类表达式的名称是类的主体的本地名称。 123456789101112131415//匿名的类let Rou = class &#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; &#125;//命名的类let Rou = class Remou&#123; constructor(name,age) &#123; this.name = name; this.age = age; &#125; &#125; 注意: 类表达式也同样受到类声明中提到的提升问题的困扰。 类的方法和定义 一个类的类体是一对花括号 {} 中的部分。这是你定义类成员的位置，如方法或构造函数。 严格模式 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。 考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。 类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，getter和setter都在严格模式下执行。 constructor 方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 1234567class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; 上面代码中，定义了一个空的类Point，JavaScript 引擎会自动为它添加一个空的constructor方法。 constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;Foo()// TypeError: Class constructor Foo cannot be invoked without &apos;new&apos; 类的实例化对象生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。123456789class Point &#123; // ...&#125;// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3); 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty(&apos;x&apos;) // truepoint.hasOwnProperty(&apos;y&apos;) // truepoint.hasOwnProperty(&apos;toString&apos;) // falsepoint.__proto__.hasOwnProperty(&apos;toString&apos;) // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与 ES5 的行为保持一致。 与 ES5 一样，类的所有实例共享一个原型对象。12345var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__//true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。这也意味着，可以通过实例的__proto__属性为“类”添加方法。 __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。12345678910var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return &apos;Oops&apos; &#125;;p1.printName() // &quot;Oops&quot;p2.printName() // &quot;Oops&quot;var p3 = new Point(4,2);p3.printName() // &quot;Oops&quot; 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的proto属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。 Class 表达式与函数一样，类也可以使用表达式的形式定义。12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。123let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 上面代码表示，Me只在 Class 内部有定义。如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 const MyClass = class { /* ... */ };采用 Class 表达式，可以写出立即执行的 Class。1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;(&apos;张三&apos;);person.sayName(); // &quot;张三&quot; 上面代码中，person是一个立即执行的类的实例。私有方法私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。 1234567891011121314class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125; 上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。 1234567891011class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125; 上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 1234567891011121314151617const bar = Symbol(&apos;bar&apos;);const snaf = Symbol(&apos;snaf&apos;);export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ...&#125;; 上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 this 的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 12345678910111213class Logger &#123; printName(name = &apos;there&apos;) &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property &apos;print&apos; of undefined 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 1234567class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125; 另一种解决方法是使用箭头函数。 123456789class Logger &#123; constructor() &#123; this.printName = (name = &apos;there&apos;) =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; 还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。(目前水平达不到先记录一下) 12345678910111213141516171819function selfish (target) &#123; const cache = new WeakMap(); const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key); if (typeof value !== &apos;function&apos;) &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy = new Proxy(target, handler); return proxy;&#125;const logger = selfish(new Logger()); name属性由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。 12class Point &#123;&#125;Point.name // &quot;Point&quot; name属性总是返回紧跟在class关键字后面的类名。Class 的取值函数（getter）和存值函数（setter）与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return &apos;getter&apos;; &#125; set prop(value) &#123; console.log(&apos;setter: &apos;+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// &apos;getter&apos; 上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。存值函数和取值函数是设置在属性的 Descriptor 对象上的。 1234567891011121314151617181920class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get html() &#123; return this.element.innerHTML; &#125; set html(value) &#123; this.element.innerHTML = value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, &quot;html&quot;);&quot;get&quot; in descriptor // true&quot;set&quot; in descriptor // true 上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。Class 的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 1234567891011class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;Foo.classMethod() // &apos;hello&apos;var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。12345678910111213class Foo &#123; static bar () &#123; this.baz(); &#125; static baz () &#123; console.log(&apos;hello&apos;); &#125; baz () &#123; console.log(&apos;world&apos;); &#125;&#125;Foo.bar() // hello 上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。父类的静态方法，可以被子类继承。 12345678910class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // &apos;hello&apos; 上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。静态方法也是可以从super对象上调用的。 12345678910111213class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + &apos;, too&apos;; &#125;&#125;Bar.classMethod() // &quot;hello, too&quot; Class 的静态属性和实例属性静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。 12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 上面的写法为Foo类定义了一个静态属性prop。 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。 12345678910// 以下两种写法都无效class Foo &#123; // 写法一 prop: 2 // 写法二 static prop: 2&#125;Foo.prop // undefined new.target 属性new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 12345678910111213141516171819function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error(&apos;必须使用 new 命令生成实例&apos;); &#125;&#125;// 另一种写法function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error(&apos;必须使用 new 命令生成实例&apos;); &#125;&#125;var person = new Person(&apos;张三&apos;); // 正确var notAPerson = Person.call(person, &apos;张三&apos;); // 报错 上面代码确保构造函数只能通过new命令调用。 Class 内部调用new.target，返回当前 Class。 123456789class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); this.length = length; this.width = width; &#125;&#125;var obj = new Rectangle(3, 4); // 输出 true 需要注意的是，子类继承父类时，new.target会返回子类。 1234567891011121314class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); // ... &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); &#125;&#125;var obj = new Square(3); // 输出 false 上面代码中，new.target会返回子类。 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 1234567891011121314151617class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error(&apos;本类不能实例化&apos;); &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(length, width) &#123; super(); // ... &#125;&#125;var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 上面代码中，Shape类不能被实例化，只能用于继承。 注意，在函数外部，使用new.target会报错。]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array方法]]></title>
    <url>%2FArray%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[join()join(separator): 将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。1234var arr = [1,2,3];console.log(arr.join()); // 1,2,3console.log(arr.join(&quot;-&quot;)); // 1-2-3console.log(arr); // [1, 2, 3]（原数组不变） 通过join()方法可以实现重复字符串，只需传入字符串以及重复的次数，就能返回重复后的字符串，函数如下：12345function repeatString(str, n) &#123;return new Array(n + 1).join(str);&#125;console.log(repeatString(&quot;abc&quot;, 3)); // abcabcabcconsole.log(repeatString(&quot;Hi&quot;, 5)); // HiHiHiHiHi push()和pop()push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。1234567var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];var count = arr.push(&quot;Jack&quot;,&quot;Sean&quot;);console.log(count); // 5console.log(arr); // [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;, &quot;Sean&quot;]var item = arr.pop();console.log(item); // Seanconsole.log(arr); // [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;] shift() 和 unshift()shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。unshift:将参数添加到原数组开头，并返回数组的长度 。 这组方法和上面的push()和pop()方法正好对应，一个是操作数组的开头，一个是操作数组的结尾。1234567var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];var count = arr.unshift(&quot;Jack&quot;,&quot;Sean&quot;);console.log(count); // 5console.log(arr); //[&quot;Jack&quot;, &quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]var item = arr.shift();console.log(item); // Jackconsole.log(arr); // [&quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;] sort()sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。 在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串，因此会出现以下的这种情况：12345var arr1 = [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;];console.log(arr1.sort()); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]arr2 = [13, 24, 51, 3];console.log(arr2.sort()); // [13, 24, 3, 51]console.log(arr2); // [13, 24, 3, 51](元数组被改变) 为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：1234567891011function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return -1; &#125; else if (value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;arr2 = [13, 24, 51, 3];console.log(arr2.sort(compare)); // [3, 13, 24, 51] 如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：1234567891011function compare(value1, value2) &#123; if (value1 &lt; value2) &#123; return 1; &#125; else if (value1 &gt; value2) &#123; return -1; &#125; else &#123; return 0; &#125;&#125;arr2 = [13, 24, 51, 3];console.log(arr2.sort(compare)); // [51, 24, 13, 3] reverse()reverse()：反转数组项的顺序。123var arr = [13, 24, 51, 3];console.log(arr.reverse()); //[3, 51, 24, 13]console.log(arr); //[3, 51, 24, 13](原数组改变) concat()concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。1234var arr = [1,3,5,7];var arrCopy = arr.concat(9,[11,13]);console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]console.log(arr); // [1, 3, 5, 7](原数组未被修改) 从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？123var arrCopy2 = arr.concat([9,[11,13]]);console.log(arrCopy2); //[1, 3, 5, 7, 9, Array[2]]console.log(arrCopy2[5]); //[11, 13] 上述代码中，arrCopy2数组的第五项是一个包含两项的数组，也就是说concat方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到arrCopy2中。 slice()slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。12345678910var arr = [1,3,5,7,9,11];var arrCopy = arr.slice(1);var arrCopy2 = arr.slice(1,4);var arrCopy3 = arr.slice(1,-2);var arrCopy4 = arr.slice(-4,-1);console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)console.log(arrCopy); //[3, 5, 7, 9, 11]console.log(arrCopy2); //[3, 5, 7]console.log(arrCopy3); //[3, 5, 7]console.log(arrCopy4); //[5, 7, 9] arrCopy只设置了一个参数，也就是起始下标为1，所以返回的数组为下标1（包括下标1）开始到数组最后。arrCopy2设置了两个参数，返回起始下标（包括1）开始到终止下标（不包括4）的子数组。arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。 splice()splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。 splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。 12345678910var arr = [1,3,5,7,9,11];var arrRemoved = arr.splice(0,2);console.log(arr); //[5, 7, 9, 11]console.log(arrRemoved); //[1, 3]var arrRemoved2 = arr.splice(2,0,4,6);console.log(arr); // [5, 7, 4, 6, 9, 11]console.log(arrRemoved2); // []var arrRemoved3 = arr.splice(1,1,2,4);console.log(arr); // [5, 2, 4, 4, 6, 9, 11]console.log(arrRemoved3); //[7] indexOf()和 lastIndexOf()indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。在比较第一个参数与数组中的每一项时，会使用全等操作符。123456var arr = [1,3,5,7,7,5,3,1];console.log(arr.indexOf(5)); //2console.log(arr.lastIndexOf(5)); //5console.log(arr.indexOf(5,2)); //2console.log(arr.lastIndexOf(5,4)); //2console.log(arr.indexOf(&quot;5&quot;)); //-1 forEach()forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。12345678910var arr = [1, 2, 3, 4, 5];arr.forEach(function(x, index, a)&#123;console.log(x + &apos;|&apos; + index + &apos;|&apos; + (a === arr));&#125;);// 输出为：// 1|0|true// 2|1|true// 3|2|true// 4|3|true// 5|4|true map()map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 下面代码利用map方法实现数组中每个数求平方。12345var arr = [1, 2, 3, 4, 5];var arr2 = arr.map(function(item)&#123;return item*item;&#125;);console.log(arr2); //[1, 4, 9, 16, 25] filter()filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。12345var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];var arr2 = arr.filter(function(x, index) &#123;return index % 3 === 0 || x &gt;= 8;&#125;);console.log(arr2); //[1, 4, 7, 8, 9, 10] every()every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。123456789var arr = [1, 2, 3, 4, 5];var arr2 = arr.every(function(x) &#123;return x &lt; 10;&#125;);console.log(arr2); //truevar arr3 = arr.every(function(x) &#123;return x &lt; 3;&#125;);console.log(arr3); // false some()some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。123456789var arr = [1, 2, 3, 4, 5];var arr2 = arr.some(function(x) &#123;return x &lt; 3;&#125;);console.log(arr2); //truevar arr3 = arr.some(function(x) &#123;return x &lt; 1;&#125;);console.log(arr3); // false reduce()和 reduceRight()这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。 传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。 下面代码用reduce()实现数组求和，数组一开始加了一个初始值10。12345var values = [1,2,3,4,5];var sum = values.reduceRight(function(prev, cur, index, array)&#123;return prev + cur;&#125;,10);console.log(sum); //25]]></content>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
</search>
